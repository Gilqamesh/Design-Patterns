1. Strategy Pattern: defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm
    vary independently from clients that use it.
2. Observer Pattern: defines a one-to-many dependency between objects so that when one object changes state, all of its dependents are
	notified and updated automatically.
3. Decorator Pattern: attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to
    subclassing for extending functionality.
4.1. Factory Method Pattern: defines an interface for creating and object, but lets subclasses decide which class to instantiate.
    Factory Method lets a class defer instantiation to subclasses.
4.2. Abstract Factory Pattern: provides an interface for creating families of related or dependent objects without specifying
    their concrete classes.
